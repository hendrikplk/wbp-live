'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* global Meteor */

var _uuid = require('uuid');

var _uuid2 = _interopRequireDefault(_uuid);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Join = function () {
  function Join(data) {
    _classCallCheck(this, Join);

    var self = this;

    var name = data.name,
        interval = data.interval,
        maxWaiting = data.maxWaiting,
        doJoin = data.doJoin,
        context = data.context,
        isShared = data.isShared,
        log = data.log;

    // NOTE: _id is used to find and clear the instance when the publication is stopped

    self._id = _uuid2.default.v1();

    self.name = name;
    self.interval = interval;
    self.doJoin = Meteor.bindEnvironment(doJoin);
    self.contexts = [context];
    self.lastPublished = new Date(0);
    self.lastRunDoJoin = new Date(0);
    self.isPublishing = false;
    self.maxWaiting = maxWaiting || 5000;
    self.currentPublishedValue = undefined;
    self.isShared = !!isShared;
    self.log = log;

    self._initPublishValueForContext(context, self.currentPublishedValue);
  }

  _createClass(Join, [{
    key: '_initPublishValueForContext',
    value: function _initPublishValueForContext(context, value) {
      context.added('PublishJoin', this.name, { value: value });
    }
  }, {
    key: '_changed',
    value: function _changed(value) {
      var self = this;

      self.contexts.forEach(function (context) {
        return context.changed('PublishJoin', self.name, {
          value: value
        });
      });
      self.log('Published data on join ' + self.name + ' - ' + self._id + ' on ' + self.contexts.length + ' context(s)', 7);
    }
  }, {
    key: '_getLastRunDoJoinTime',
    value: function _getLastRunDoJoinTime() {
      return this.lastRunDoJoin.getTime();
    }
  }, {
    key: '_getLastPublishedTime',
    value: function _getLastPublishedTime() {
      return this.lastPublished.getTime();
    }
  }, {
    key: '_isPublishingButExceedMaxWaitingTime',
    value: function _isPublishingButExceedMaxWaitingTime() {
      var now = new Date().getTime();

      return this.isPublishing && now - this._getLastRunDoJoinTime() >= this.maxWaiting;
    }
  }, {
    key: '_isNotPublishingAndExceedIntervalTime',
    value: function _isNotPublishingAndExceedIntervalTime() {
      var now = new Date().getTime();

      return !this.isPublishing && now - this._getLastPublishedTime() >= this.interval;
    }
  }, {
    key: '_findContextIndex',
    value: function _findContextIndex(_ref) {
      var _subscriptionId = _ref._subscriptionId,
          connection = _ref.connection;

      return this.contexts.findIndex(function (c) {
        return c._subscriptionId === _subscriptionId && (c.connection || {}).id === (connection || {}).id;
      });
    }
  }, {
    key: '_removeContextAtIndex',
    value: function _removeContextAtIndex(index) {
      if (index > -1) {
        this.contexts.splice(index, 1);
      }
    }
  }, {
    key: 'removeContext',
    value: function removeContext(context) {
      var contextIndex = this._findContextIndex(context);

      this._removeContextAtIndex(contextIndex);
    }
  }, {
    key: 'addContext',
    value: function addContext(context) {
      this._initPublishValueForContext(context, this.currentPublishedValue);
      this.contexts.push(context);
    }
  }, {
    key: 'isContextsEmpty',
    value: function isContextsEmpty() {
      return this.contexts.length === 0;
    }
  }, {
    key: 'needPublish',
    value: function needPublish() {
      return this._isPublishingButExceedMaxWaitingTime() || this._isNotPublishingAndExceedIntervalTime();
    }
  }, {
    key: 'publish',
    value: function publish() {
      var self = this;

      try {
        self.log('Start publishing data on join ' + self.name + ' - ' + self._id, 7);
        self.isPublishing = true;
        self.lastRunDoJoin = new Date();
        var value = self.doJoin();

        if (value instanceof Promise) {
          value.then(function (data) {
            self._changed(data);
          });
        } else {
          self._changed(value);
        }

        self.lastPublished = new Date();
        self.isPublishing = false;
        self.currentPublishedValue = value;
      } catch (e) {
        self.log(e && (e.stack || e.message) || e, 3);
      }
    }
  }]);

  return Join;
}();

exports.default = Join;